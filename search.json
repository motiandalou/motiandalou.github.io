[{"title":"控制台打印公司名字","url":"/2023/09/10/%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%85%AC%E5%8F%B8%E5%90%8D%E5%AD%97/","content":"啰嗦的话:\n\n平时开发的产品,自己公司的产品,可以在控制台里面打印一些信息,比如公司 logo,校园招聘之类的,针对性还是蛮强的,一般的用户是不知道打开控制台的,它甚至都不知道控制台,能打开的一般都是搞技术的.招聘啥的,那对用户群体就比较精准了,比如下面这张百度的校园招聘.\n\n\n下面介绍如何在控制台制作一个公司 logo 以及你想要表达的信息,就以上面这张图片的百度举例吧.\n第一步:–打开网站: https://patorjk.com/software/taag/#p=display&amp;f=Graffiti&amp;t=Type%20Something%20 \n\n第二步:在电脑桌面新建一个空的 word 文档,将在网站生成的 baidu 字母复制出来,然后粘贴在 word 里面 –&gt; Ctrl + H 键 \n\n\n\\ 替换成 \\\\ (转义) \n&#96; 替换成 替换成 ‘(或者在前面加个\\防止转义) \n\n\n\nps: 放在 console.log 里面,我这边安装了 vetur 插件,无法转义会报错.手动改一下就行了\n第三步:将 word 替换好的字母,放在控制台显示即可.\n// console.log要用反引号   console.log(`     _           _     _   | |         (_)   | |   | |__   __ _ _  __| |_   _   | &#x27;_ \\\\  / _\\` | /| _\\` | | | |   | |_) | (_| | | (_| | |_| |   |_.__/ \\\\ __,_|_|\\\\ __,_|\\\\ __,_|   这是一个最好的时代，   科技的发展给予了每个人创造价值的可能性；   这也是一个最充满想象的时代，   每一位心怀梦想的人，终会奔向星辰大海。   百度与你们一起仰望星辰大海，携手共筑未来！   `);   console.log(&#x27;%c百度2023校园招聘简历投递:&#x27;,&#x27;color: red&#x27;,&#x27;https://talent.baidu.com/jobs/list&#x27;)\n\n\n","categories":["Vue2"],"tags":[]},{"title":"主题换肤","url":"/2023/09/03/%E4%B8%BB%E9%A2%98%E6%8D%A2%E8%82%A4/","content":"\n主题换肤,目前为止,实现的方法有很多,不管方法怎么变化,基于我目前水平,我认为就两点 第一点: 你要为每个主题写一个单独的 css 文件 第二点: 你要在什么时候引入.— 实现这两个,换肤功能也就实现了.其它的就是不同方法的加载用户体验的问题了第一点没什么优化的空间,第二点,引入的时间可以变化变化 \n\n啰嗦的话: 做该功能调研的时候,我也看了一些目前基于 vue 新的实现方式,但是我不确定兼容性,因为 vue2&#x2F;3 要求的浏览器版本就已经比较高了.我个人的话不推荐,还是采用工程化的传统方法.换肤功能并不难,主要是麻烦,尤其是你项目如果开发到 70% 的情况下,再做这个功能,那就比较难受了.\n\n\n第一种实现方式: 牺牲首屏加载时间,进入首页的时候就将所有的换肤的 css 文件加载,切换的时候就很快. \n\n\n实现思想: 每次切换主题,直接把 body 标签的 class 换成对应的主题名称,相当于直接做了样式覆盖\n\n/* 主题--白 */body.day .box &#123;  color: #f90;  background: #fff;&#125;/* 主题--黑 */body.dark .box &#123;  color: #eee;  background: #333;&#125;.box &#123;  width: 100px;  height: 100px;  border: 1px solid #000;&#125;&lt;div class=&quot;box&quot;&gt;  &lt;p&gt;hello&lt;/p&gt;&lt;/div&gt;&lt;p&gt;  选择样式：  &lt;button onclick=&quot;change(&#x27;day&#x27;)&quot;&gt;day&lt;/button&gt;  &lt;button onclick=&quot;change(&#x27;dark&#x27;)&quot;&gt;dark&lt;/button&gt;&lt;/p&gt;function change(theme) &#123;  document.body.className = theme;&#125;\n\n\n第二种实现方式: 牺牲切换时间,首屏加载就小了一部分压力.按需加载文件,比如我要蓝色就加载蓝色主题的文件,黑色主题的就要黑色主题的. \n\n\n啰嗦的话: 这个方法我看张鑫旭的博客他介绍过,比如我们没用 vue,react 这些框架之前,写一个 index.html 文件,html 放在 body 标签 里面,js 放在 script 标签 里面,css 通过 link 标签 引入( link 标签是一个引入外部资源的标签 )\n实现思想: 创建一个 link 标签,切换主题的时候,动态切换 link 标签的 href 属性.即可实现该方式\n\nfunction writeLink(id = &#x27;linkCss&#x27;, href) &#123;    const oldStyleDom = document.getElementById(id)    const linkDom = document.createElement(&#x27;link&#x27;)    linkDom.href = href    linkDom.rel = &quot;stylesheet&quot;    linkDom.type = &quot;text/css&quot;    linkDom.id = id    oldStyleDom ? document.head.replaceChild(linkDom, oldStyleDom) : document.head.appendChild(linkDom)&#125;\n\n\n第三种实现方式: 使用 elementUI 和 AntDesign &#x2F; \n\n\n现在我们做项目,大部分都是使用 elementUI 和 AntDesign 这些样式组件,搭配 vue 或者 react 做\n实现思想: 白&#x2F;黑主题,各写一个 css 文件,里面定义各个用功能划分的颜色,在具体的组件里面使用 var(…).底层实现原理: 各个组件去遍历对应的 css 文件,找到同名的颜色变量名称,对应显示.\n\n\n\n第四种实现方式: vue3 的新方式 &#x2F; \n\n\n这个方式虽然有局限性(只能在 vue 使用),但是提供了也挺好的,相当于给 css 写活了,可以自己全局封装一下,用变量控制.不然像 vue2 或者其它框架没有提供这个方法,只能写原生 js,来动态控制了.\n实现思想: 其实就是给元素绑定 CSS 变量，在绑定的数据更新时调用 CSSStyleDeclaration.setProperty 更新 CSS 变量值。\n\n&lt;script setup&gt;  const theme = &#123;    color: &#x27;red&#x27;  &#125;&lt;/script&gt;&lt;template&gt;    &lt;p&gt;hello&lt;/p&gt;&lt;/template&gt;&lt;style scoped&gt;  p &#123;    color: v-bind(&#x27;theme.color&#x27;);  &#125;&lt;/style&gt;\n\n\n结语: 新的技术出来,还有新的方法(比如: SCSS + mixin + 类名切换 &#x2F; CSS 变量+动态 setProperty),没有最好,只有最适合.","categories":["Vue2"],"tags":[]},{"title":"RN 环境搭建,项目创建,开发中遇到的坑,打包,发布","url":"/2023/08/27/React%20Native%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA,%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA,%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91,%E6%89%93%E5%8C%85,%E5%8F%91%E5%B8%83/","content":"背景: 公司自研的容灾项目,有配套的小程序和 APP1. 环境搭建\n\n(1). 前提: 需要一个代理,用来科学上网,因为有外国的网站下载,会比较慢,我用的代理,还是比较快的,上个公司薅的.哈哈, 1 个小时就全部下的差不多了. (2). 必需的三个软件: Node(版本大于等于 14) , JDK(版本 1.8 及其以上) , Android Studio(国外网站) (3). 引用网址:https://blog.csdn.net/jin_mu_yan/article/details/130729266  引用别人的文章,写的挺好的,从头跟到尾,一路下载安装环境即可.\n\n\n\n项目创建 引用网址: https://zhuanlan.zhihu.com/p/213878203  创建一个 RN 项目,从文章的后半部分看即可,创建之后可能有些坑,我总结一下我踩的坑 – 创建项目,指定一个版本,默认是安装最新的,有些依赖版本会报错,命令: npx react-native init MyApp –version 0.68.2 – 1. Android studio 模拟器卡死: https://blog.csdn.net/jackzhouyu/article/details/129118272 – 2. Unable to start the daemon process: https://blog.csdn.net/m0_65065082/article/details/130347653 – 3. 任何一级文件目录,都不要使用中文!!!!(巨坑,报的错瞎报,我看 cmd 窗口里面,路径没有解析出来,才想到不能写中文…) – ps: 创建项目: npx react-native init MyApp –version 0.68.2 – ps: 启动项目: yarn react-native run-android – ps: 建议用 yarn\n\n\n\n项目中间遇到的坑: 持续更新中…\n\n\n\n打包: 项目刚开始,还没到这里…后续完善安卓打包: http://www.taodudu.cc/news/show-1153293.html?action=onClick ios 打包: 持续更新中…\n\n\n\n发布: 最后发布到应用商店,项目刚开始,还没到这里…持续更新中…\n\n","categories":["React Native"],"tags":[]},{"title":"vue2 index.html / App.vue / main.js 三者作用","url":"/2023/08/20/vue2%E4%B8%89%E4%B8%AA%E4%B8%BB%E8%A6%81%E6%96%87%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","content":"index.html &#x2F; App.vue &#x2F; main.jsvue 创建任何一个项目,都会默认有这三个文件.  这里整理一下,有些小的东西,看似不起眼.理清了,也有贯穿上下文,承上启下的作用.尤其是看源码的时候,文件从哪里进来,怎么挂载,你要是自己写一个 vue,第一步的思路就有了.\n\nindex.html–主页,项目入口. 作用: 网站页面的总入口  你打开一个 vue 网站,第一件事就是打开这个页面,条件允许的情况下,也就是 vue 没有加载好的情况下(可能发生在一些性能较差的电脑或者网络不好的等等情况下),短暂的显示 index.html 中正文的内容(没写就是空白)\n\n\n\n\nApp.vue–根组件 作用: 你要写的 vue 项目的主组件 App.vue 用来写初始的模板代码,你写的页面和组件, 都要挂载在这个 DOM 元素上,你可以理解它为你的整个 vue 项目.\n\n\n\n\nmain.js 作用: main.js 用来 New Vue 对象，同时将 App.vue 中的模板内容挂载到 index.html 中(index.html,没有 vue 这个框架,它就在. 要让作者写的 vue 框架起作用,即怎么显示? 作为一个 DOM 插入到网页中即可)。在项目运行中，main.js 作为项目的入口文件，运行中，找到其实例需要挂载的位置，即 index.html 中，这样 vue 这个框架,第一步就成功了，源码就可以继续往下写了… index.html 的挂载点处的内容会被显示，但是随后就被实例(new Vue())中的组件(componets: App)中的模板中的内容所取代，所以我们会看到有那么一瞬间会显示出 index.html 中正文的内容。这个文件也同时是引入外部文件进来的地方,比如饿了么组件,axios 等等\n\n\n\n这三个都不是孤立的,都可以串联起来.\n","categories":["Vue2"],"tags":[]},{"title":"vue2传值的8种方式","url":"/2023/08/13/vue2%E4%BC%A0%E5%80%BC%E7%9A%848%E7%A7%8D%E6%96%B9%E5%BC%8F/","content":"总结:常见使用场景可以分为三类:\n(1). 这 8 种方式我在项目中非常常用,但是也要根据情况而定,啥都用的话,数据不好管理,多人开发,项目非常大的话,像我们公司按年为单位来计算的开发迭代项目,时间长的话,就成屎山了.(2). 我个人算是个极简主义者,代码量和代码方式,越简单越好,这样越方便管理,一个功能的实现逻辑和方式有很多,团队的话,商量之后,尽量用一种.这样你同事请假,今天必须帮他改个 bug,这种开发成本就最低了.同伙之间平时多沟通.(3). 团队合作,代码方便管理永远放第一位.\n\n\n父子组件通信: 5 个: props; $parent &#x2F; $children; provide &#x2F; inject ; ref ; $attrs &#x2F; $listeners\n兄弟组件通信: 2 个eventBus Vuex ,子&gt;&gt;父&gt;&gt;子(不推荐多层嵌套)\n跨级通信: 4 个eventBus Vuex provide &#x2F; inject 、$attrs &#x2F; $listeners\n\n\n第一种: 父子组件传值:props 子父组件传值:$emit第二种: $children &#x2F; $parent第三种: provide&#x2F; inject 局部刷新第四种: ref &#x2F; refs第五种: eventBus第六种: Vuex第七种: localStorage &#x2F; sessionStorage第八种: $attrs 与 $listeners\n\n第一种:父子组件传值 子父组件传值父子组件传值: props\n子父组件传值: $emit\n父子组件传值进阶版:修饰符&lt;HelloWorld :money.sync=&quot;dataApp&quot;&gt;&lt;/HelloWorld&gt;等同于:两句作用等同&lt;HelloWorld :money=&quot;dataApp&quot; v-on:update:money=&quot;dataApp = $event&quot;/&gt;\n\n第二种:$children &#x2F; $parent  只能进行父子组件之间进行传值父子组件可以相互之间获取彼此之间所有的方法和data,就像访问一样子组件访问父组件: this.$parent父组件访问子组件: this.$children[0]\n\n第三种: provide&#x2F; inject概念:provide&#x2F; inject 是 vue2.2.0 新增的 api, 简单来说就是父组件中通过 provide 来提供变量, 然后再子组件中通过 inject 来注入变量。注意: 这里不论子组件嵌套有多深, 只要调用了 inject 那么就可以注入 provide 中的数据，而不局限于只能从当前父组件的 props 属性中回去数据举例:一共三个组件 A–&gt;B–&gt;–C (A 是父组件 B 是子组件 C 是孙组件) A 组件 provide 注入一个值,B 组件,C 组件 inject 都可以获取到该值.优点:不局限于父子组件传值,父孙传值也可以实现.不用写 props.缺点:父孙传值多了个没用的子组件.\n如果多人开发,可以配合 mixin 混合组件开发\n\n第四种:ref &#x2F; refshttps://www.cnblogs.com/goloving/p/9404099.html两种方式:ref：第一种方式:如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；普通的元素分为:ref 作用在子组件外面的元素上,都是指向 dom 元素,不同 this 指向父组件实例ref 作用在子组件里面面的元素上,都是指向 dom 元素,不同 this 指向子组件实例\n第二种方式:如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据，工作实战:如何利用 v-for 和 ref 获取一组数组或者 dom 节点(比如 类似多个饿了么手风琴)\n\n第五种:eventBus所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所有组件都可以通知其他组件。缺点:当项目较大,就容易造成难以维护的灾难.(可能自己都找不到自己写的发送事件)\n使用方式:情况描述:eventBus,当第一次通过路由跳转页面的时候控制台是没有任何输出的，只有第二次跳转开始控制台才有输出\n原因:vue-router 切换的时候，会先加载新的组件，当新的组件渲染好但是还没 mount 的时候，销毁旧组件，然后再挂载新组件，也就是说当 B 页面的生命周期进行到 beforeMount 的时候，下一步走到的就是 A 页面的 beforeDestory 方法和接下去的 destroyed 方法eventBus 的执行生命周期:\n解析:其实，可以通过结果清楚看到，当我们还在页面 A 的时候，页面 B 还没生成，也就是页面 B 中的 created 中所监听的来自于 A 中的事件还没有被触发。这个时候当你 A 中 emit 事件的时候，B 其实是没有监听到的。再看一下，红色的是 B 页面组件，当你从页面 A 到页面 B 跳转的时候，发生了什么？首先是先 B 组件先 created 然后 beforeMount 接着 A 组件才被销毁，A 组件才执行 beforeDestory，以及 destoryed.所以，我们可以把 A 页面组件中的 emit 事件写在 beforeDestory 中去。因为这个时候，B 页面组件已经被 created 了，也就是我们写的$on事件已经触发了所以可以，在beforeDestory的时候，$emit 事件。\n第一步:在 main.js 里面全局定义://全局定义，可以将 eventBus 绑定到 vue 实例的原型上,也可以直接绑定到 window 对象上.Vue.prototype.$EventBus = new Vue();第二步:在想要发送信息的页面,发送事件beforeDestroy() &#123;// 第一种办法:setTimeout(() =&gt; &#123;//传多个值,用&#123;&#125;包裹键值对this.$EventBus.$emit(&quot;new&quot;, &quot;lsy&quot;);&#125;, 0);// 第二种办法:this.$nextTick(()=&gt;&#123;      //传多个值,用&#123;&#125;包裹键值对      this.$EventBus.$emit(&quot;new&quot;, &quot;lsy&quot;);&#125;)&#125;,第三步:在想要获取信息的页面,获取信息mounted() &#123;//必须要在 mounted 以及之前的周期里面写,不然获取不到 eventbus 信息//这里不用箭头函数的话,this 会丢失.也可以先保存一份:this.$EventBus.$on(&quot;new&quot;, (e) =&gt; &#123;this.name = e;console.log(e);&#125;);&#125;,beforeDestroy() &#123;//移除监听//on 事件是不会自动清除的，也就是说你切换的次数越多 on 监听也会越来越//多，解决的方法是需要在 B 页面的 beforeDestroy 里面手动使用 on 监听也会//越来越多，解决的方法是需要在 B 页面的 beforeDestroy 里面手动使用 off//去关闭监听:this.$EventBus.$off(&quot;new&quot;, &quot;&quot;);&#125;,\n\n\n第六种:VuexVuex 是什么?Vuex 是一个专为 Vue 程序开发的状态管理模式。Vuex 解决了什么问题?两个问题:问题一:多个视图依赖于同一状态问题二:来自不同视图的行为需要变更同一状态将开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上\nVuex 详细 5 个模块:1.state: 将需要进行管理的共享数据，放入 state 中，使其形似为全局变量(全局状态)2.getters: 相当于 computed 计算属性，用于加工处理 state 状态数据，有其两个默认参数，第一个默认参数为 state，第二个默认参数为 getters。条件:如果很多组件都使用这个过滤后的数据.3.mutations: 同步提交数据4.actions: actions 的异步操作5.modules: 模块化 Vuex，为了方便后期对于项目的管理，可以让每一个模块拥有自己的 state、mutation、action、getters,使得结构非常清晰，方便管理。\nindex.js模块化:\n\n第七种:localStorage &#x2F; sessionStorage缺点:这种通信比较简单,缺点是数据和状态比较混乱,不太容易维护。解决方法:localStorage &#x2F; sessionStorage 可以结合 Vuex, 实现数据的持久保存,同时使用 Vuex 解决数据和状态混乱问题.实际工作中也就是这么用.业务情景 1: 1.填写表单数据,点击提交按钮,然后将 v-model 获取的表单数据,本地存储到本地. 2.再将值放到 Vuex 里面也进行保存一份3.Vuex,里面的 state.就很清晰的管理全局状态了.同时再次初始化的时候,会优先使用本地存储. 4.实际工作中,可能是后端返回给你前端的一个 token,用来验证登录的.你每次用这个用来登录用.举例用法:\n\n第八种: $attrs 与 $listeners解决问题:隔代组件传参:X 套 Y,Y 套 Z X 传属性值给 Z 或者 Z 传方法给 X(实际也是传值) 这样就实现双向隔代传值正常思路:思路一:使用 props 绑定来进行一级一级的信息传递, 如果 D 组件中状态改变需要传递数据给 A, 使用事件系统一级级往上传递思路二:使用 eventBus,这种情况下还是比较适合使用, 但是碰到多人合作开发时, 代码维护性较低, 可读性也低思路三:使用 Vuex 来进行数据管理, 但是如果仅仅是传递数据, 而不做中间处理,使用 Vuex 处理感觉有点大材小用了.\n正向:$attrs\n逆向:$listeners\n关于 Vue 的 inheritAttrs 的理解,https://blog.csdn.net/qq_38211541/article/details/105824684自己总结:现在要 X 通过$attrs属性传值,Z组件会接收到所有的属性,两种情况:情况一:当inheritAttrs&#x3D;true Z组件会接收到所有的属性情况二:当inheritAttrs&#x3D;false  Z组件不会接收到任何属性inheritAttrs&#x3D;true&#x2F;false都不会影响$attrs 传值.都有值.只是子组件 DOM 节点上是否继承父组件的属性用法:加在 Y,Z 继承组件上.\n","categories":["Vue2"],"tags":[]},{"title":"基金组合的力量","url":"/2023/07/30/%E5%9F%BA%E9%87%91%E7%BB%84%E5%90%88/","content":"\n如果你掌握了 股票基金 &#x2F; 债券基金 &#x2F; 货币基金 &#x2F; 大宗商品 等方面的知识,实际操作了股票或者基金之后,你会发现组合的力量,单个的基金,并不具备抗风险的能力,但是基金组合有,正确的投资组合,可能每年下来,能稳定的进行增长.举个例子: A 股里面不是所有的股票都是同时涨的,或者跌的,有些正相关,负相关,进行基金组合,比买单个的抗风险能力强很多. 当然,组合里面的基金要选好.这是另外一个话题了.\n\n\n\n⭐1. 策略一: 瑞-达利殴–全天候策略–股票(30%): 选取沪深 300–债券(55%): 选取中证全债–黄金(7.5%): 选取黄金 ETF–大宗商品(7.5%): 选取大宗商品 ETF每年至少进行一次再平衡\n\n\n⭐2. 策略二: 低相关性– 股票型基金– 债券型基金– 大宗商品型基金\n持有比例? 1.稳健型:20%股基 + 60%债基 + 20%大宗商品 2.进取型:50%股基 + 30%债基 + 20%大宗商品 3.激进型:70%股基 + 10%债基 + 20%大宗商品(√)F每年至少进行一次再平衡\n\n\n如何选取对应的品种?(1). 股票型基金?–双十基金经理(5 只基金): 任期超过十年 + 年化收益率超过 10% + 最大回撤不超过 35%–5 年超额收益基金经理(5 只基金): 任期大于 5 年小于 10 年 + 年化收益率超过 25%–新兴基金经理(5 只基金): 任期大于 3 年小于 5 年 + 年化收益率超过 50%\n\n\n(2). 债券型基金(5 只基金)?–最大回撤不超过 5%,年收益在 6% 以上为标准\n\n\n(3). 宗商品型基金?–成立在 3 年以上的 5 只大宗商品型基金 (大宗商品 + 白银基金 + 黄金 ETF + 商品 ETF + 嘉实原油)大宗商品基金的作用是: 防止股票和债券基金双杀(都低)\n\n","categories":["基金"],"tags":[]},{"title":"如何购买股票基金--主动基金","url":"/2023/07/30/%E5%A6%82%E4%BD%95%E8%B4%AD%E4%B9%B0%E8%82%A1%E7%A5%A8%E5%9F%BA%E9%87%91--%E4%B8%BB%E5%8A%A8%E5%9F%BA%E9%87%91/","content":"\n前面的话: 我每天有个习惯,微信公众号,每天晚上九点的样子,就会去看 银行螺丝钉 每日更新基金方面的文章,我是 银行螺丝钉 的粉丝,我看过他写的两本书,他的投资价值理念,对我有启蒙作用,以及我也十分认同这种投资理念.并且实际生活中我的大部分资金也都是按照这个理念进行投资的,算是没见过面的老师吧.很感谢,作为自己个人,把书中,基于目前自己的学识与眼见,能读到的知识进行了整理,并且记录了一下.好记性不如烂笔头,并且书嘛,常看常新.\n\n\n\n书籍:主动基金投资指南\n\n\n\n购买主动基金( 非常看基金经理的能力 )公式: 好品种 + 好价格 + 长期持有 &#x3D; 好收益\n\n(1). 如何选 好品种?( 书中常谈: 买基金就是买基金经理 )—常见基金公司( 打开支付宝基金模块基本都是好公司 )–不同的公司有不同的投资风格( 价值,均衡,成长 ),本人( 坚持价值风格 ),从风格找公司,再找公司优秀的基金经理.—优秀的基金经理: 老将( 年化收益率 &gt;&#x3D; 15%(股票基金平均年收益率是 14%) + 从业时间 &gt;&#x3D; 10 年 + 管理资金规模 &gt;&#x3D; 20 亿 ) + 黑马(老将的徒弟 &#x2F; 从业时间–黑马暂时看不出来,凭直觉… )\n(2). 如何选 好价格?—按风格( 支付宝–&gt;): 价值风格参考(沪深 300,价值 300 指数等前面带价值两个字的 ),价值风格要买低估的,当指数是低估的,往往价值风格的基金也是低估的–螺丝钉等级(微信号: 银行螺丝钉–&gt;指数估值–&gt;今日估值 ) 获取螺丝钉等级,4-5 星定投\n(3). 长期持有\n\n低估的时候,坚持定投即可.\n更千万别频繁买卖,追涨杀跌.不用每天看,一个月看一次就行了.心态很重要.其实我天天看,涨和跌对我来言,只是每天的一个消遣工具.现在,涨和跌完全不会影响我的任何情绪.不以物喜,不以己悲 这是我一辈子的修行,生活中我一直都在做一些刻意修炼.\n\n\n\n⭐ 螺丝钉等级:\n\n4-5 星( 最佳,但是机会很少 ),低估的时候主要定投 股票基金\n3 星,考虑止盈,让股票基金占比( 100 - 你的年龄 ),将盈利的资金投入债券基金, 继续达到开始的占比: 股票基金 : 债券基金 &#x3D; (100-年龄) : 年龄\n2 星,股票基金比例降到 30%\n1 星,股票基金止盈,全部卖出.全部买入债券基金\n\n\n\n⭐ 投资风格: 三个大类\n\n价值风格: 低市盈率,低市净率(一句话总结: 股票是最便宜的)\n成长风格: 高市盈率,高市净率,高盈利成长,高盈利增长速度(一句话总结: 长的高位,最后一哆嗦)\n均衡风格: 估值没有特别高,特别低,在正常的那种(一句话总结: 既要价值风格的低价格,又要成长风格的好公司(挑选又好又便宜的股票))\n\n\n\n看指数的低估: 支付宝–&gt;基金–&gt;指数选基–&gt;指数排行–随便点开一个指数就可以看见是否低估.\n\n","categories":["基金"],"tags":[]},{"title":"如何购买股票基金--被动基金","url":"/2023/07/30/%E5%A6%82%E4%BD%95%E8%B4%AD%E4%B9%B0%E8%82%A1%E7%A5%A8%E5%9F%BA%E9%87%91--%E8%A2%AB%E5%8A%A8%E5%9F%BA%E9%87%91/","content":"\n前面的话: 我每天有个习惯,微信公众号,每天晚上九点的样子,就会去看 银行螺丝钉 每日更新基金方面的文章,我是 银行螺丝钉 的粉丝,我看过他写的两本书,他的投资价值理念,对我有启蒙作用,以及我也十分认同这种投资理念.并且实际生活中我的大部分资金也都是按照这个理念进行投资的,算是没见过面的老师吧.很感谢,作为自己个人,把书中,基于目前自己的学识与眼见,能读到的知识进行了整理,并且记录了一下.好记性不如烂笔头,并且书嘛,常看常新.\n\n\n书籍: 指数基金投资指南\n\n\n有哪些方法? 2 种( 盈利收益率法 &#x2F; 博格公式法 )\n\n1. 盈利收益率法\n2. 博格公式法(市盈率)\n3. 博格公式法(市净率)\n\n\n\n哪些指数,用哪些方法呢?\n\n\n盈利收益率法:\n\n\n 上证 50 指数,上证红利指数,上证 50AH 指数,中证红利指数,基本面 50 指数,央视 50 指数,恒生指数,H 股指数\n\n\n\n博格公式法(市盈率):沪深 300 指数,中证 500 指数,创业板指数,红利机会指数,必须消费行业指数,可选消费行业指数,医药行业指数,养老行业指数\n博格公式法(市净率):证券行业指数,金融行业指数,非银金融行业指数,地产行业指数\n\n\n\n什么是盈利收益率法,博格公式法(市盈率),博格公式法(市净率)?\n\n盈利收益率法: 公司盈利稳定,看指标盈利收益率(X)\n1. X &gt; 10% 时,分批投资\n2. 6.4% &lt; X &lt; 10% 不再买入,坚持已有的基金份额\n3. X &lt; 6.4% 分批卖出基金(分批分散风险)\n\n博格公式法(市盈率)\n1. 公司盈高速增长,即低估的时候买入,市盈率小于 10,且股息率高\n\n博格公式法(市净率,建议暂时先别使用,盈利不稳定,不好判断)\n1. 公司盈利不稳定/周期性变化的情况下,市净率,即低估的时候买入\n\n\n\n如何购买–债券基金?\n\n\n十年国债利率: 大于 3.5%,买入长债券基金基金, 低于 3.5%, 大于 3.2% 买入短债券基金 &#x2F; 即也要同时减持股票基金 (因为债券基金和股票基金是反的)\n十年国债利率:当十年国债利率跌破 2.6% 的时候果断卖出\n\n\n\n如何选一只对应的指数基金产品?\n\n—费用低,跟踪误差低(越低越好),规模最少一亿(防止清盘)\n\n\n\n⭐ 国内各种基金长期平均收益率:\n\n1. 货币基金:2%-3%(短期定投选择--放些平时用的闲钱即可)\n2. 债券基金: 6.4%(中期定投选择)\n3. 股票基金(主动):14%(长期定投选择) 股票基金(被动):10%(长期定投选择)\n\n\n⭐ 是否是高股息率: 4%\n\n\n5% 属于高股息,至少在 3% 才能投资\n\n\n⭐ 个人: 最直接的办法,我投 指数基金 这块,直接看的螺丝钉的每日更新文章,每月发工资了进行定投.\n","categories":["基金"],"tags":[]},{"title":"动态配置协议,域名,端口","url":"/2023/07/29/%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE,%E5%9F%9F%E5%90%8D,%E7%AB%AF%E5%8F%A3/","content":"需求: 考虑一个成品的项目会给到各地方进行部署，而每个地方的 ip 和端口均无法保证统一，为了抽离开发人员的工作，需要对项目进行一定的配置，配置后的项目，只需要修改打包后的配置文件，填写相关的 ip 和端口，即可实现项目的部署。\n\n前面的话:\n\nvue 项目,public&#x2F;static 文件夹存放的是静态资源.\nwebpack 不会打包 public&#x2F;static 文件夹下面的文件,只是简单的复制 copy,打包之后,你会直接在包里面看到一个跟 public&#x2F;static 一模一样的文件夹,里面存放着你的静态文件.\npublib 和 static 都是可以配置的,哪些文件夹不进行打包.你一般开一个项目都是叫 static.这都可以参考公司其它的项目怎么写的,团队写作嘛.大家看见一个文件名,都知道是什么意思.也可以减少其它同伙的阅读成本.\n\n\n实现步骤:\n\n在自己开发的 vue 项目,public&#x2F;static 文件夹下面,新建一个 config.js 文件,用来配置协议,域名,端口.\n再将该文件,引入到 index.html 入口文件里面.拿到 config.js 全局的配置变量 PLATFORM_CONFIG\naxios 配置文件 应用一下这个 baseURL 即可\n\n\nconfig.js 文件\n\n/** * @desc 协议, 不填写则默认取头部的协议 * @value &#x27;http:&#x27;, &#x27;https:&#x27; *  */const protocol = &quot;&quot;;/** * @desc 域名或者IP地址，不填写则默认当前地址 *  */const host = &quot;10.0.3.169&quot;;/** * @desc 端口，不填写则默认当前端口 *  */const port = &quot;8089&quot;;//API 接口配置信息const api_protocol = `$&#123;protocol&#125;` || window.location.protocol;const api_host = `$&#123;host&#125;` || window.location.hostname;const api_port = `$&#123;port&#125;` || window.location.port;let PLATFORM_CONFIG = &#123;  // 基础URL  baseURL: api_protocol + &quot;//&quot; + api_host + &quot;:&quot; + api_port,  // 接口请求超长时间  timeout: &quot;1000&quot;&#125;;\n\n\nindex.html 文件\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot; /&gt;    &lt;title&gt;个人网站&lt;/title&gt;    &lt;!-- 引入接口配置文件 --&gt;    &lt;script src=&quot;./public/config.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n","categories":["Vue2"],"tags":[]},{"title":"国际化(vue2 + elementUI)","url":"/2023/07/23/%E5%9B%BD%E9%99%85%E5%8C%96(vue2%20+%20elementUI)/","content":"第一步: 安装\n\n先下载国际化的包:注意版本,可以去 npm 社区 直接下载对应的版本,最直接的办法,找下载数量最多的版本\n\nnpm i vue-i18n@8.28.2\n\n\n第二步: 配置及使用\n\n在 src 目录新建 i18n 目录，en.json 为英文语言包，zh.json 为中文语言包,，tw.json 为繁体语言包等等语言\n\n\n&#123;  &quot;common&quot;: &#123;    &quot;username&quot;: &quot;用户名: &#123;name&#125;&quot;,    &quot;password&quot;: &quot;密码&quot;,    &quot;save&quot;: &quot;保存&quot;,    &quot;edit&quot;: &quot;编辑&quot;,    &quot;update&quot;: &quot;更新&quot;,    &quot;delete&quot;: &quot;删除&quot;,    &quot;forever&quot;: &quot;永久&quot;,    &quot;expired&quot;: &quot;过期&quot;  &#125;&#125;\n\n&#123;  &quot;common&quot;: &#123;    &quot;username&quot;: &quot;用戶名: &#123;name&#125;&quot;,    &quot;password&quot;: &quot;密碼&quot;,    &quot;save&quot;: &quot;保存&quot;,    &quot;edit&quot;: &quot;編輯&quot;,    &quot;update&quot;: &quot;更新&quot;,    &quot;delete&quot;: &quot;刪除&quot;,    &quot;forever&quot;: &quot;永久&quot;,    &quot;expired&quot;: &quot;過期&quot;  &#125;&#125;\n\n&#123;  &quot;common&quot;: &#123;    &quot;username&quot;: &quot;username: &#123;name&#125;&quot;,    &quot;password&quot;: &quot;password&quot;,    &quot;save&quot;: &quot;save&quot;,    &quot;edit&quot;: &quot;edit&quot;,    &quot;update&quot;: &quot;update&quot;,    &quot;delete&quot;: &quot;delete&quot;,    &quot;forever&quot;: &quot;forever&quot;,    &quot;expired&quot;: &quot;expired&quot;  &#125;&#125;\n\n\ni18n 目录下(即文件包同级目录) 新建 index.js 文件\n\nimport Vue from &quot;vue&quot;;import VueI18n from &quot;vue-i18n&quot;;// element-ui lang导入Element的语言包 英文import elementEnLocale from &quot;element-ui/lib/locale/lang/en&quot;;// element-ui lang g导入Element的语言包 中文import elementZhLocale from &quot;element-ui/lib/locale/lang/zh-CN&quot;;// 导入项目中用到的英文语言包import enLocale from &quot;./en&quot;;// 导入项目中用到的中文语言包import zhLocale from &quot;./zh&quot;;Vue.use(VueI18n);const messages = &#123;  en: &#123;    ...enLocale,    ...elementEnLocale  &#125;,  zh: &#123;    ...zhLocale,    ...elementZhLocale  &#125;&#125;;const i18n = new VueI18n(&#123;  // 当前语种  locale: localStorage.getItem(&quot;language&quot;) || &quot;zh&quot;,  // 本地语言包（&#x27;en&#x27;,&#x27;zh&#x27;...）  messages,  // 如果当前语种不存在时，默认设置当前语种  fallbackLocale: &quot;zh&quot;,  // 设置 数字格式化  numberFormats: &#123;    //设置 数字本地化    en: &#123;      currency: &#123;        //添加 $        style: &quot;currency&quot;,        currency: &quot;USD&quot;      &#125;    &#125;,    zh: &#123;      currency: &#123;        //添加 ￥        style: &quot;currency&quot;,        currency: &quot;JPY&quot;,        currencyDisplay: &quot;symbol&quot;      &#125;    &#125;  &#125;,  // 设置 时间日期格式化  dateTimeFormats: &#123;    //设置 日期时间本地化    en: &#123;      short: &#123;        year: &quot;numeric&quot;,        month: &quot;short&quot;,        day: &quot;numeric&quot;      &#125;,      long: &#123;        year: &quot;numeric&quot;,        month: &quot;short&quot;,        day: &quot;numeric&quot;,        weekday: &quot;short&quot;,        hour: &quot;numeric&quot;,        minute: &quot;numeric&quot;      &#125;    &#125;,    zh: &#123;      short: &#123;        year: &quot;numeric&quot;,        month: &quot;short&quot;,        day: &quot;numeric&quot;      &#125;,      long: &#123;        year: &quot;numeric&quot;,        month: &quot;short&quot;,        day: &quot;numeric&quot;,        weekday: &quot;short&quot;,        hour: &quot;numeric&quot;,        minute: &quot;numeric&quot;      &#125;    &#125;  &#125;&#125;);export default i18n;\n\n\n在主入口文件 main.js 中,引入上一步的 i18n 文件夹里面的 index.js 文件\n\nimport Vue from &quot;vue&quot;;import App from &quot;./App&quot;;import router from &quot;./router&quot;;// 引入公共样式import &quot;@/assets/css/common.css&quot;;// 引入全局样式import &quot;@/assets/css/cover.less&quot;;// 引入elementUIimport ElementUI from &quot;element-ui&quot;;//导入配置好的国际化语言包import &#123; i18n, loadLanguageAsync &#125; from &quot;./i18n&quot;;// 阻止 vue 在启动时生成生产提示Vue.config.productionTip = false;// 通过插件的形式挂载，通过全局方法 Vue.use() 使用插件Vue.use(ElementUI);new Vue(&#123;  el: &quot;#app&quot;,  router,  components: &#123; App &#125;,  // 注入 配置好的国际化语言配置  i18n,  template: &quot;&lt;App/&gt;&quot;&#125;);// 路由拦截router.beforeEach((to, from, next) =&gt; &#123;  // to.params.lang 路由拿到语言的值  const lang = to.params.lang || &quot;zh&quot;;  loadLanguageAsync(lang).then(() =&gt; next());&#125;);\n\n\nVue I18n 使用方法: 官网: https://kazupon.github.io/vue-i18n/zh/\n\n// 个人常用// 第一种: template&#123;&#123; $t(&#x27;save&#x27;) &#125;&#125;// 第二种: js函数中this.$t(&#x27;save&#x27;)// 第三种: 动态传参: 命名格式化(第二参数是一个对象，就代表了所有需要动态添加的内容)// 模板代码&#123;&#123;    $t(&quot;common.username&quot;, &#123;      name: &quot;刘亦菲&quot;    &#125;)&#125;&#125;// 国际化文件&#123;  &quot;common&quot;: &#123;    &quot;username&quot;: &quot;用户名: &#123;name&#125;&quot;,  &#125;&#125;//- object对象类型会直接输出  [object Object]//- boolean布尔类型会按照字符串输出  true--&gt;&quot;true&quot;/false--&gt;&quot;false&quot;//- array数组类型中，如果每一项都是 数值或者字符串 那么 直接输出,否则按上述情况显示// 第四种: $tc 的使用 （复数）// 第五种: $d  日期时间格式化  todo:待补充 https://www.cnblogs.com/perferect/p/13344370.html  dateTimeFormats: &#123;    //设置 日期时间本地化    en: &#123;      // 显示英文 年 月 日      short: &#123;        year: &quot;numeric&quot;,        month: &quot;short&quot;,        day: &quot;numeric&quot;      &#125;,      // 显示英文 年 月 日 星期 小时 分钟      long: &#123;        year: &quot;numeric&quot;,        month: &quot;short&quot;,        day: &quot;numeric&quot;,        weekday: &quot;short&quot;,        hour: &quot;numeric&quot;,        minute: &quot;numeric&quot;      &#125;    &#125;,    zh: &#123;      // 显示中文 年 月 日      short: &#123;        year: &quot;numeric&quot;,        month: &quot;short&quot;,        day: &quot;numeric&quot;      &#125;,      // 显示中文 年 月 日 星期 小时 分钟      long: &#123;        year: &quot;numeric&quot;,        month: &quot;short&quot;,        day: &quot;numeric&quot;,        weekday: &quot;short&quot;,        hour: &quot;numeric&quot;,        minute: &quot;numeric&quot;      &#125;    &#125;    // 2023年7月23日    &lt;p&gt;&#123;&#123; $d(new Date(), &quot;short&quot;) &#125;&#125;&lt;/p&gt;    // 2023年7月23日周日 21:32    &lt;p&gt;&#123;&#123; $d(new Date(), &quot;long&quot;) &#125;&#125;&lt;/p&gt;    // 2023年7月23日    &lt;p&gt;&#123;&#123; $d(new Date(), &quot;short&quot;, &quot;zh&quot;) &#125;&#125;&lt;/p&gt;    // 2023年7月23日周日 21:32    &lt;p&gt;&#123;&#123; $d(new Date(), &quot;long&quot;, &quot;zh&quot;) &#125;&#125;&lt;/p&gt;// 第六种: $n（数字本地化） （复数） 待补充    $n（number,&#x27;path&#x27;,&#x27;locale&#x27;）方法，三个参数：    -  用户传入数字 必传    -  调用的格式化方案 必传    -  使用的语种，默认是当前this.$i18n.locale 非必传    numberFormats:&#123;        &#x27;en&#x27;: &#123;            currency: &#123; //添加 $            style: &#x27;currency&#x27;, currency: &#x27;USD&#x27;         &#125;        &#125;,        &#x27;zh&#x27;: &#123;            currency: &#123; //添加 ￥            style: &#x27;currency&#x27;, currency: &#x27;JPY&#x27;, currencyDisplay: &#x27;symbol&#x27;            &#125;        &#125;      &#125;,    // $100.00    &lt;p&gt;&#123;&#123; $n(100, &#x27;currency&#x27;) &#125;&#125;&lt;/p&gt;    // ￥100    &lt;p&gt;&#123;&#123; $n(100, &#x27;currency&#x27;, &#x27;zh&#x27;) &#125;&#125;&lt;/p&gt;\n\n\n动态加载语言包: 一次加载所有的语言包是没有必要的，特别是语言包过多的情况下，影响首屏加载速度,官网上也是给了解决方式的。\n\n原理: 默认预装一个语言,比如中文,当切换本地存储的语言类型的时候,再动态加载对应的文件夹里面的语言包文件\n\n// 官网链接: https://kazupon.github.io/vue-i18n/zh/guide/lazy-loading.htmlimport Vue from &quot;vue&quot;;import VueI18n from &quot;vue-i18n&quot;;// element-ui lang导入Element的语言包 英文import elementEnLocale from &quot;element-ui/lib/locale/lang/en&quot;;// element-ui lang g导入Element的语言包 中文import elementZhLocale from &quot;element-ui/lib/locale/lang/zh-CN&quot;;// element-ui lang g导入Element的语言包 繁体import elementTwLocale from &quot;element-ui/lib/locale/lang/zh-TW&quot;;// 导入项目中用到的 英文 语言包import enLocale from &quot;./lang/en.json&quot;;// 导入项目中用到的 中文 语言包import zhLocale from &quot;./lang/zh.json&quot;;// 导入项目中用到的 繁体 语言包import twLocale from &quot;./lang/tw.json&quot;;// 引入axiosimport axios from &quot;axios&quot;;// 通过插件的形式挂载，通过全局方法 Vue.use() 使用插件Vue.use(VueI18n);const messages = &#123;  en: &#123;    ...enLocale,    ...elementEnLocale  &#125;,  zh: &#123;    ...zhLocale,    ...elementZhLocale  &#125;,  tw: &#123;    ...twLocale,    ...elementTwLocale  &#125;&#125;;// 预装默认语言const loadedLanguages = [&quot;zh&quot;];export const i18n = new VueI18n(&#123;  // 当前语种  locale: localStorage.getItem(&quot;language&quot;) || &quot;zh&quot;,  // 本地语言包（&#x27;en&#x27;,&#x27;zh&#x27;,&#x27;tw&#x27;...）  messages,  // 如果当前语种不存在时，默认设置当前语种  fallbackLocale: &quot;zh&quot;,  // 设置 数字格式化  numberFormats: &#123;    //设置 数字本地化    en: &#123;      currency: &#123;        //添加 $        style: &quot;currency&quot;,        currency: &quot;USD&quot;      &#125;    &#125;,    zh: &#123;      currency: &#123;        //添加 ￥        style: &quot;currency&quot;,        currency: &quot;JPY&quot;,        currencyDisplay: &quot;symbol&quot;      &#125;    &#125;  &#125;,  // 设置 时间日期格式化  dateTimeFormats: &#123;    //设置 日期时间本地化    en: &#123;      short: &#123;        year: &quot;numeric&quot;,        month: &quot;short&quot;,        day: &quot;numeric&quot;      &#125;,      long: &#123;        year: &quot;numeric&quot;,        month: &quot;short&quot;,        day: &quot;numeric&quot;,        weekday: &quot;short&quot;,        hour: &quot;numeric&quot;,        minute: &quot;numeric&quot;      &#125;    &#125;,    zh: &#123;      short: &#123;        year: &quot;numeric&quot;,        month: &quot;short&quot;,        day: &quot;numeric&quot;      &#125;,      long: &#123;        year: &quot;numeric&quot;,        month: &quot;short&quot;,        day: &quot;numeric&quot;,        weekday: &quot;short&quot;,        hour: &quot;numeric&quot;,        minute: &quot;numeric&quot;      &#125;    &#125;  &#125;&#125;);// 设置国际化--语言function setI18nLanguage(lang) &#123;  i18n.locale = lang;  // 设置axios请求头  axios.defaults.headers.common[&quot;Accept-Language&quot;] = lang;  document.querySelector(&quot;html&quot;).setAttribute(&quot;lang&quot;, lang);  return lang;&#125;export function loadLanguageAsync(lang) &#123;  // 如果语言相同  if (i18n.locale === lang) &#123;    return Promise.resolve(setI18nLanguage(lang));  &#125;  // 如果语言已经加载  if (loadedLanguages.includes(lang)) &#123;    return Promise.resolve(setI18nLanguage(lang));  &#125;  // 根据路由传进来的值--lang(设置的语言)--如果尚未加载语言  return import(`./lang/$&#123;lang&#125;.json`).then(messages =&gt; &#123;    // 会重设框架的语言环境，如果在调用这个方法之前语言环境里面有文件那么会覆盖这个文件    i18n.setLocaleMessage(lang, messages.default);    // 加入--预装默认语言    loadedLanguages.push(lang);    // 设置国际化--语言    return setI18nLanguage(lang);  &#125;);&#125;\n\n\n最后本地开发,如果不想看见很多的嵌套(应该都不想),可以 vscode(我目前使用的编译器) 下载插件 i18n Ally\n\n配置可能会踩坑,百度: i18n Ally 如何使用即可\n效果展示如下:\n\n// 使用前&lt;div&gt;&#123;&#123; $t(&quot;common.edit&quot;) &#125;&#125;&lt;/div&gt;// 使用后&lt;div&gt;&#123;&#123; $t(&quot;编辑&quot;) &#125;&#125;&lt;/div&gt;\n","categories":["Vue2"],"tags":[]},{"title":"filter(过滤器)属性","url":"/2023/02/26/filter(%E8%BF%87%E6%BB%A4%E5%99%A8)%E5%B1%9E%E6%80%A7/","content":"\n前言: filter属性 我在日常开发用的并不多,但是我觉得很管用,有奇效,在一些特殊的样式上,你会觉得还可以这么简单就能实现.\n\n\n定义: filter 属性定义了元素(通常是img标签)的可视效果(例如：模糊与饱和度)。\n语法: filter: none | blur() | brightness() | contrast() | drop-shadow() | grayscale() | hue-rotate() | invert() | opacity() | saturate() | sepia() | url();\n\n\n\nblur 高斯模糊 (常用)\nbrightness 亮度 (常用)\ncontrast 对比度 (常用)\ndrop-shadow 阴影 (重点)\ngrayscale  灰度 (常用)\nhue-rotate 应用色相 (不常用)\ninvert 反转输入图像 (不常用)\nopacity 透明度 (常用)\nsaturate 图像饱和度  (不常用)\nsepia 将图像转换为深褐色 (常用)\nurl (不用)\n\n\n\nblur\n\n语法: filter: blur(4px);\n\n模糊度。默认为0, 值(px,不能写百分比)越大,越模糊.\n\n\n\nbrightness \n\n语法: filter: brightness(200%);\n\n亮度。默认为1&#x2F;100%, 图片没有变化,0是图片全黑,1是默认值颜色不变,值越大,图片越亮(即发白).\n\n\n\ncontrast \n\n语法: contrast(200%);\n\n对比度。默认为1&#x2F;100%, 图片没有变化,0是图片全黑,1是默认值颜色不变,值越大,对比度(即绿色更绿.黄色更黄).\n\n\n\ndrop-shadow 重点\n\n语法: filter: drop-shadow(8px 8px 10px red); \n\n第一个参数(必填): X轴水平位置(8px,即阴影向右移8px,负值相反)\n第二个参数(必填): y轴水平位置(8px,即阴影向上移8px,负值相反)\n第三个参数(选填): 模糊度(默认为0,值需要大于0),值越大,越模糊\n第四个参数(选填): 阴影颜色\n\n\nps:与box-shadow的区别: inset + spread + 阴影叠加\n语法: box-shadow: (inset,8px 8px 10px spread red); \n\ninset: 不填写,默认是向外阴影,设置inset(即内部阴影)\nspread: 默认值0(阴影和元素尺寸一致),控制阴影的范围扩大(值 &gt; 0,值越大,阴影越大)或者缩小(值 &lt; 0,阴影搜索)\n阴影叠加: box-shadow值可以用逗号隔开,第一个层级(z-index)最高(8px(即阴影半径)),其次16px,最后24px.我们可以理解成一个圆心的靶子.\n\nbox-shadow: 0 0 0 8px #f0f, \t\t\t0 0 0 16px #d00, \t\t\t0 0 0 24pxpx #cdd, \n\n\n\ngrayscale \n\n语法: filter: grayscale(50%);\n\n灰度。默认为0(图像无变化),最大值100%(完全变灰色).\n\n\n\nhue-rotate\n\n语法: filter: hue-rotate(90deg);\n\n给图像应用色相旋转。默认为0deg(图像没有变化),一圈(0deg-360deg)效果循环,基本找不出规律(除非你对颜色很有研究),随着值的变化,你可以看到,粉色,紫色,棕色,粉红色,橙色..各种美丽的颜色.\n\n\n\ninvert\n\n语法: filter: invert(100%);\n\n反转输入图像。默认为0(图像没有变化), 50%(灰色), 100%(医院拍CT的片子一样).\n\n\n\nopacity\n\n语法: filter: opacity(30%);\n\n透明度。默认为0(图像没有变化), 最大值100%(完全透明),值越大,透明度越高.\n\n\n\nsaturate\n\n语法: filter: saturate(800%);\n\n转换图像饱和度。默认为100%(图像无变化), 0(完全不饱和),值越大,饱和度越大(即颜色越鲜艳).\n\n\n\nsepia\n\n语法: filter: sepia(100%);\n\n将图像转换为深褐色。默认为0(图像无变化),最大值100%(完全变深褐色).\n\n\n\nurl (没用过,不知道退役之前能不能用上)\n\n语法: filter: url(svg-url#element-id)\n\n默认为0, 值(px,不能写百分比)越大,越模糊.\n\n\n\n日常前端开发需要注意的点\n\n\ngrayscale,可以用在网页一些特殊日子,网页全部变成灰色\ndrop-shadow 可以与box-shadow 可以按需求,交替&#x2F;对比使用,日常开发中,会有意想不到的效果.\nopacity(所有元素都具有透明度)&#x2F;rgba(背景出现透明效果，但上面的文字不透明)进行设置透明度,可以按需求,交替&#x2F;对比使用.\nsepia可以做成有年代感照片的效果.\n\n","categories":["CSS"],"tags":[]},{"title":"flex弹性布局","url":"/2023/02/18/flex%E5%B8%83%E5%B1%80/","content":"\ndisplay:flex 布局在平常 PC 端和手机端,对于其可视化区域的适配发挥着比较重要的作用,是一个我们前端日常开发会频繁使用的布局方式.接下来记录一下我在日常前端开发中接触到的属性,一共 7 个\n\n\nflex-direction(极常用)\nflex-wrap(极常用)\njustify-content(极常用)\nalign-items(极常用)\nalign-content(极常用)\nalign-self(一般性使用)\nflex(不常用,难点)\n\n\n\n\nflex-direction\n\n\n语法: flex-direction: row(默认值) | row-reverse | column | column-reverse\n\n\nrow：横向从左到右排列（左对齐），默认的排列方式。\nrow-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面。\ncolumn：纵向排列。\ncolumn-reverse：反转纵向排列，从后往前排，最后一项排在最上面。\n\n\n\n\nflex-wrap 属性用于指定弹性盒子的子元素换行方式。\n\n\n语法: flex-wrap: nowrap(默认值)|wrap|wrap-reverse|initial|inherit;\n\n\nnowrap - 默认不换行， 弹性容器为单行。该情况下弹性子项可能会溢出容器。\nwrap - 换行,弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行\nwrap-reverse -换行且反转,即反转 wrap 排列。\n\n\n\n\njustify-content 内容对齐 属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。\n\n\n语法: justify-content: flex-start | flex-end | center | space-between | space-around\n\n\nflex-start：弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的 main-start 外边距边线被放置在该行的 main-start 边线，而后续弹性项依次平齐摆放。\nflex-end：弹性项目向行尾紧挨着填充。第一个弹性项的 main-end 外边距边线被放置在该行的 main-end 边线，而后续弹性项依次平齐摆放。\ncenter：弹性项目居中紧挨着填充。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。\nspace-between：弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于 flex-start。否则，第 1 个弹性项的外边距和行的 main-start 边线对齐，而最后 1 个弹性项的外边距和行的 main-end 边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。\nspace-around：弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于 center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是 20px），同时首尾两边和弹性容器之间留有一半的间隔（1&#x2F;2*20px&#x3D;10px）。\n\n\n\n\nalign-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。\n\n\n语法: align-items: flex-start | flex-end | center | baseline | stretch\n\n\nflex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。\nflex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。\ncenter：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。\nbaseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。\nstretch：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min&#x2F;max-width&#x2F;height’属性的限制。\n\n\n\nalign-content 属性用于修改 flex-wrap 属性的行为。类似于 align-items, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐。\n\n\n语法: flex-start | flex-end | center | space-between | space-around | stretch\n\n\nstretch - 默认。各行将会伸展以占用剩余的空间。\nflex-start - 各行向弹性盒容器的起始位置堆叠。\nflex-end - 各行向弹性盒容器的结束位置堆叠。\ncenter -各行向弹性盒容器的中间位置堆叠。\nspace-between -各行在弹性盒容器中平均分布。\nspace-around - 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。\n\n\n\n\nalign-self 属性用于设置弹性元素自身在侧轴（纵轴）方向上的对齐方式。\n\n\n语法: auto | flex-start | flex-end | center | baseline | stretch\n\n\nauto：如果’align-self’的值为’auto’，则其计算值为元素的父元素的’align-items’值，如果其没有父元素，则计算值为’stretch’。\nflex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。\nflex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。\ncenter：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。\nbaseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。\nstretch：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min&#x2F;max-width&#x2F;height’属性的限制。\n\n\n\n\nflex 属性用于指定弹性子元素如何分配空间。\n\n\n语法: flex: auto | initial | none | inherit |  [ flex-grow ] || [ flex-shrink ] || [ flex-basis ]\n\n\nflex-start：弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的 main-start 外边距边线被放置在该行的 main-start 边线，而后续弹性项依次平齐摆放。\nflex-end：弹性项目向行尾紧挨着填充。第一个弹性项的 main-end 外边距边线被放置在该行的 main-end 边线，而后续弹性项依次平齐摆放。\ncenter：弹性项目居中紧挨着填充。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。\nspace-between：弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于 flex-start。否则，第 1 个弹性项的外边距和行的 main-start 边线对齐，而最后 1 个弹性项的外边距和行的 main-end 边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。\nspace-around：弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于 center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是 20px），同时首尾两边和弹性容器之间留有一半的间隔（1&#x2F;2*20px&#x3D;10px）。\n\n\n日常前端开发需要注意的点\n\n\nflex 布局使用的话,float 浮动就会失效,但是定位不会,可以继续用\n难点是 flex 的使用\n\n","categories":["CSS"],"tags":[]}]